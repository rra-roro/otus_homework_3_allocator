# otus_homework_3_allocator
<b>Особенности моей реализации такие:</b>
    
1)	Мой аллокатор custom_allocator написан в стиле аллокаторов <b>С++17</b>, 
    соответственно мой контейнер custom_forward_list так же написан с поддержкой аллокаторов <b>С++17</b>, 
    т.е. вся работа с аллокатороми в контейнере идет через <b>allocator_traits<></b>
    Проблем со сборкой кода на travis не столкнулся, поскольку ранее уже перешел на gcc версии 8.
    
2)	В рамках домашки следующее не требовалось, но созданный аллокатор, позволяет:

        a.	Выделят память их кучи блоками, размер которых можно задавать как при компиляции, так 
            и менять размер блоков во время работы. Количество таких блоков не ограничено, т.е. 
            аллокатор динамически расширяет размер резервируемой памяти. Контейнерам же память выдается кусочками
            из этих блоков.

        b.	Задавать в параметрах шаблона отдельно размер первоначально резервируемой памяти (размер первого блока), 
            и размер последующих выделений памяти из кучи (размер последующих блоков). По умолчанию и там и там 1 так, 
            что по умолчанию мой аллокатор ведет себя как аллокатор стандартной библиотеки, т.е. 
            никаких блоков не резервирует, а выделяет память из кучи непосредственно.

        с.	Эти же два параметра, можно задавать через конструктор аллокатора, что имеет 
             приоритет над параметрами заданными через параметры шаблона. Что позволяет нам 
             оптимизировать выделения памяти в рантайме.

        d.	Так же размер последующих выделений памяти (размер последующих блоков), можно поменять в рантайме, через 
             соответствующую ф-ию аллокатора. Это возможно даже после того, как аллокатор передан в контейнер и 
             контейнер начал его использовать. 

    Более подробно эти возможности можно посмотреть в тестах.

    Тестирование моего аллокатора через стандартный профилировщик Visual Studio 2017 показало, 
    что вставка в map<int,int> 100000 элементов на x64 съедает 4,5Mb оперативки против 11Mb со стандартным аллокатором.

3)	Мой контейнер – это урезанный forward_list, который выполняет только те операции, 
    что требуются в домашнем задании. Проход по элементам контейнера сделал через итератор так, 
    что контейнер совместим с алгоритмами, которым требуется forward_iterator и циклом foreach.

4)	С факториалом получилась некоторая заминка. 
    
    Особенности работы программы ltrace в начале работы над кодом мне были не известны, 
    так что я решил, что неплохо будет прикрутить к домашнему заданию парочку дополнительных библиотек: 
      boost/math, boost/multiprecision, и GMP библиотеку для вычислений с плавающей запятой, целыми и 
      рациональными числами с произвольной точностью.
      
    Хотелось в рамках домашки протестировать библиотеки для расчетов чисел, выходящих за диапазон 
    стандартных типов С++.
    
    Но когда я уже все закончил и запустил команду <b>ltrace allocator</b>, стало понятно, что 
    вывод команды ltrace – совсем не читаемый. Так что я переделал вычисление факториала. 
    Добавив по умолчанию его наивную реализацию.
 
    Хотя вывод ltrace allocator  все же остается громоздким, теперь при вызове ltrace allocator все же 
    можно найти вызовы выделения памяти, что делает map и custom_forward_list с дефолтным аллокатором 
    стандартной библиотеки, и выделения памяти, что делает мой custom_allocator.

    Наивную версию вычисления факториала, можно переключить на версию с boost/math, boost/multiprecision, и GMP, 
    если при запуске allocator задать дополнительный параметр: 
    
     <b>allocator -max_item <i>size</i></b>
     
    где <i>size</i> - это число элементов контейнера, т.е. другими словами, это то число, до которого мы будем считать факториалы.
    <i>size</i> - ничем не ограничен, только памятью компьютера и временем вычислений.

5)  Дополнительно для Visual Studio я добавил три новых targets в проект Cmake,
    что позволяет делать дополнительную проверку кода:
    *) C++ Core Guidelines checkers - 
       https://github.com/MicrosoftDocs/visualstudio-docs/blob/master/docs/code-quality/using-the-cpp-core-guidelines-checkers.md
    *) PVS_Studio checkers
    *) Customizable Naming Convention Checker - https://github.com/mapbox/cncc/tree/multi-file

<b>Для сборки проекта под Windows я использовал</b>
  - boost 1_69_0         - библиотека собрана:    .\b2 --build-type=complete --stagedir=.\
  - Googletest, mpir     - библиотеки установлены через vcpkg
 
 <b>Для сборки проекта под Linux потребуется</b>
  - см. .travis.yml
  - вместо mpir библиотека GMP

